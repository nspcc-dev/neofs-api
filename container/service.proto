syntax = "proto3";

package neo.fs.v2.container;

import "acl/types.proto";
import "container/types.proto";
import "refs/types.proto";
import "session/types.proto";
import "status/types.proto";

option csharp_namespace = "Neo.FileStorage.API.Container";
option go_package = "github.com/nspcc-dev/neofs-sdk-go/proto/container";

// `ContainerService` provides API to interact with `Container` smart contract
// in FS chain via other NeoFS nodes. All of those actions can be done
// equivalently by directly issuing transactions and RPC calls to FS chain
// nodes.
service ContainerService {
  // Sends transaction calling contract method to create container, and waits
  // for the transaction to be executed. Deadline is determined by the
  // transport protocol (e.g. `grpc-timeout` header). If the deadline is not
  // set, server waits 15s after submitting the transaction.
  //
  // Statuses:
  // - **OK** (0, SECTION_SUCCESS): \
  //   container successfully created;;
  // - Common failures (SECTION_FAILURE_COMMON);
  // - **CONTAINER_AWAIT_TIMEOUT** (3075, SECTION_CONTAINER): \
  //   transaction was sent but not executed within the deadline.
  rpc Put(PutRequest) returns (PutResponse);

  // Sends transaction calling contract method to delete container, and waits
  // for the transaction to be executed. Deadline is determined by the
  // transport protocol (e.g. `grpc-timeout` header). If the deadline is not
  // set, server waits 15s after submitting the transaction.
  // NOTE: a container deletion leads to the removal of every object in that
  // container, regardless of any restrictions on the object removal (e.g. lock/locked
  // object would be also removed).
  //
  // Statuses:
  // - **OK** (0, SECTION_SUCCESS): \
  //   container successfully removed;
  // - Common failures (SECTION_FAILURE_COMMON);
  // - **CONTAINER_LOCKED** (3074, SECTION_CONTAINER): \
  //   deleting a locked container is prohibited;
  // - **CONTAINER_AWAIT_TIMEOUT** (3075, SECTION_CONTAINER): \
  //   transaction was sent but not executed within the deadline.
  rpc Delete(DeleteRequest) returns (DeleteResponse);

  // Returns container structure from `Container` smart contract storage.
  //
  // Statuses:
  // - **OK** (0, SECTION_SUCCESS): \
  //   container has been successfully read;
  // - Common failures (SECTION_FAILURE_COMMON);
  // - **CONTAINER_NOT_FOUND** (3072, SECTION_CONTAINER): \
  //   requested container not found.
  rpc Get(GetRequest) returns (GetResponse);

  // Returns all owner's containers from 'Container` smart contract' storage.
  //
  // Statuses:
  // - **OK** (0, SECTION_SUCCESS): \
  //   container list has been successfully read;
  // - Common failures (SECTION_FAILURE_COMMON).
  rpc List(ListRequest) returns (ListResponse);

  // Sends transaction calling contract method to set container's extended ACL,
  // and waits for the transaction to be executed. Deadline is determined by
  // the transport protocol (e.g. `grpc-timeout` header). If the deadline is
  // not set, server waits 15s after submitting the transaction.
  //
  // Statuses:
  // - **OK** (0, SECTION_SUCCESS): \
  //   container eACL successfully set;
  // - Common failures (SECTION_FAILURE_COMMON);
  // - **CONTAINER_AWAIT_TIMEOUT** (3075, SECTION_CONTAINER): \
  //   transaction was sent but not executed within the deadline.
  rpc SetExtendedACL(SetExtendedACLRequest) returns (SetExtendedACLResponse);

  // Returns Extended ACL table and signature from `Container` smart contract
  // storage.
  //
  // Statuses:
  // - **OK** (0, SECTION_SUCCESS): \
  //   container eACL has been successfully read;
  // - Common failures (SECTION_FAILURE_COMMON);
  // - **CONTAINER_NOT_FOUND** (3072, SECTION_CONTAINER): \
  //   container not found;
  // - **EACL_NOT_FOUND** (3073, SECTION_CONTAINER): \
  //   eACL table not found.
  rpc GetExtendedACL(GetExtendedACLRequest) returns (GetExtendedACLResponse);

  // Announces the space values used by the container for P2P synchronization.
  //
  // Statuses:
  // - **OK** (0, SECTION_SUCCESS): \
  //   estimation of used space has been successfully announced;
  // - Common failures (SECTION_FAILURE_COMMON).
  //
  // DEPRECATED: every storage node must send storage load directly to `container`
  // contract.
  rpc AnnounceUsedSpace(AnnounceUsedSpaceRequest) returns (AnnounceUsedSpaceResponse);

  // Sends transaction calling contract method to set container attribute, and
  // waits for the transaction to be executed. Deadline is determined by the
  // transport protocol (e.g. `grpc-timeout` header). If the deadline is not
  // set, server waits 15s after submitting the transaction.
  //
  // Statuses:
  // - **OK** (0, SECTION_SUCCESS): \
  //   attribute successfully set;
  // - Common failures (SECTION_FAILURE_COMMON);
  // - **CONTAINER_AWAIT_TIMEOUT** (3075, SECTION_CONTAINER): \
  //   transaction was sent but not executed within the deadline.
  rpc SetAttribute(SetAttributeRequest) returns (SetAttributeResponse);

  // Sends transaction calling contract method to remove container attribute,
  // and waits for the transaction to be executed. Deadline is determined by
  // the transport protocol (e.g. `grpc-timeout` header). If the deadline is
  // not set, server waits 15s after submitting the transaction.
  //
  // Statuses:
  // - **OK** (0, SECTION_SUCCESS): \
  //   attribute successfully removed;
  // - Common failures (SECTION_FAILURE_COMMON);
  // - **CONTAINER_AWAIT_TIMEOUT** (3075, SECTION_CONTAINER): \
  //   transaction was sent but not executed within the deadline.
  rpc RemoveAttribute(RemoveAttributeRequest) returns (RemoveAttributeResponse);
}

// New NeoFS Container creation request
message PutRequest {
  // Container creation request has container structure's signature as a
  // separate field. It's not stored in FS chain, just verified on container
  // creation by `Container` smart contract. `ContainerID` is a SHA256 hash of
  // the stable-marshalled container strucutre, hence there is no need for
  // additional signature checks.
  //
  // Optional `eacl` field allows to set extended access rules for the
  // container. It must be either set or unset along with `eacl_signature`.
  // `eacl_session_token` or `eacl_session_token_v1` must be set along with
  // `eacl` only.
  message Body {
    // Container structure to register in NeoFS
    container.Container container = 1;

    // Signature of a stable-marshalled container according to RFC-6979.
    neo.fs.v2.refs.SignatureRFC6979 signature = 2;

    // Extended ACL for the container.
    neo.fs.v2.acl.EACLTable eacl = 3;

    // N3 witness of stable-marshalled `eacl` field. The witness must
    // authenticate either container owner or one of subjects in
    // the `eacl_session_token` field if any. Signature according to
    // `ECDSA_RFC6979_SHA256` scheme is also supported.
    neo.fs.v2.refs.SignatureRFC6979 eacl_signature = 4;

    // Optional eACL session token. The token must be issued by the container
    // owner. The token must have at least one subject authenticated
    // by `eacl_signature` field. The token must have at least one context
    // with this container and `CONTAINER_SETEACL` verb.
    neo.fs.v2.session.SessionTokenV2 eacl_session_token = 5;

    // Optional eACL session token (V1). It must not be set together with
    // `eacl_session_token` field that is highly recommended to be used
    // instead. Requirements are the same for both.
    neo.fs.v2.session.SessionToken eacl_session_token_v1 = 6;
  }
  // Body of container put request message.
  Body body = 1;

  // Carries request meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.RequestMetaHeader meta_header = 2;

  // Carries request verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.RequestVerificationHeader verify_header = 3;
}

// New NeoFS Container creation response
message PutResponse {
  // Container put response body contains information about the newly registered
  // container as seen by `Container` smart contract. `ContainerID` can be
  // calculated beforehand from the container structure and compared to the one
  // returned here to make sure everything has been done as expected.
  message Body {
    // Unique identifier of the newly created container
    neo.fs.v2.refs.ContainerID container_id = 1;
  }
  // Body of container put response message.
  Body body = 1;

  // Carries response meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.ResponseMetaHeader meta_header = 2;

  // Carries response verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.ResponseVerificationHeader verify_header = 3;
}

// Container removal request
message DeleteRequest {
  // Container removal request body has signed `ContainerID` as a proof of
  // the container owner's intent. The signature will be verified by `Container`
  // smart contract, so signing algorithm must be supported by NeoVM.
  message Body {
    // Identifier of the container to delete from NeoFS
    neo.fs.v2.refs.ContainerID container_id = 1;

    // `ContainerID` signed with the container owner's key according to RFC-6979.
    neo.fs.v2.refs.SignatureRFC6979 signature = 2;
  }
  // Body of container delete request message.
  Body body = 1;

  // Carries request meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.RequestMetaHeader meta_header = 2;

  // Carries request verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.RequestVerificationHeader verify_header = 3;
}

// `DeleteResponse` has an empty body because delete operation is asynchronous
// and done via consensus in Inner Ring nodes.
message DeleteResponse {
  // `DeleteResponse` has an empty body because delete operation is asynchronous
  // and done via consensus in Inner Ring nodes.
  message Body {}
  // Body of container delete response message.
  Body body = 1;

  // Carries response meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.ResponseMetaHeader meta_header = 2;

  // Carries response verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.ResponseVerificationHeader verify_header = 3;
}

// Get container structure
message GetRequest {
  // Get container structure request body.
  message Body {
    // Identifier of the container to get
    neo.fs.v2.refs.ContainerID container_id = 1;
  }
  // Body of container get request message.
  Body body = 1;

  // Carries request meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.RequestMetaHeader meta_header = 2;

  // Carries request verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.RequestVerificationHeader verify_header = 3;
}

// Get container structure
message GetResponse {
  // Get container response body does not have container structure signature. It
  // has been already verified upon container creation.
  message Body {
    // Requested container structure
    Container container = 1;

    // Signature of a stable-marshalled container according to RFC-6979.
    neo.fs.v2.refs.SignatureRFC6979 signature = 2;

    // Session token if the container has been created within the session
    neo.fs.v2.session.SessionToken session_token = 3;
  }
  // Body of container get response message.
  Body body = 1;

  // Carries response meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.ResponseMetaHeader meta_header = 2;

  // Carries response verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.ResponseVerificationHeader verify_header = 3;
}

// List containers
message ListRequest {
  // List containers request body.
  message Body {
    // Identifier of the container owner
    neo.fs.v2.refs.OwnerID owner_id = 1;
  }
  // Body of list containers request message
  Body body = 1;

  // Carries request meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.RequestMetaHeader meta_header = 2;

  // Carries request verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.RequestVerificationHeader verify_header = 3;
}

// List containers
message ListResponse {
  // List containers response body.
  message Body {
    // List of `ContainerID`s belonging to the requested `OwnerID`
    repeated refs.ContainerID container_ids = 1;
  }

  // Body of list containers response message.
  Body body = 1;

  // Carries response meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.ResponseMetaHeader meta_header = 2;

  // Carries response verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.ResponseVerificationHeader verify_header = 3;
}

// Set Extended ACL
message SetExtendedACLRequest {
  // Set Extended ACL request body does not have separate `ContainerID`
  // reference. It will be taken from `EACLTable.container_id` field.
  message Body {
    // Extended ACL table to set for the container
    neo.fs.v2.acl.EACLTable eacl = 1;

    // Signature of stable-marshalled Extended ACL table according to RFC-6979.
    neo.fs.v2.refs.SignatureRFC6979 signature = 2;
  }
  // Body of set extended acl request message.
  Body body = 1;

  // Carries request meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.RequestMetaHeader meta_header = 2;

  // Carries request verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.RequestVerificationHeader verify_header = 3;
}

// Set Extended ACL
message SetExtendedACLResponse {
  // `SetExtendedACLResponse` has an empty body because the operation is
  // asynchronous and the update should be reflected in `Container` smart contract's
  // storage after next block is issued in FS chain.
  message Body {}

  // Body of set extended acl response message.
  Body body = 1;

  // Carries response meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.ResponseMetaHeader meta_header = 2;

  // Carries response verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.ResponseVerificationHeader verify_header = 3;
}

// Get Extended ACL
message GetExtendedACLRequest {
  // Get Extended ACL request body
  message Body {
    // Identifier of the container having Extended ACL
    neo.fs.v2.refs.ContainerID container_id = 1;
  }

  // Body of get extended acl request message.
  Body body = 1;

  // Carries request meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.RequestMetaHeader meta_header = 2;

  // Carries request verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.RequestVerificationHeader verify_header = 3;
}

// Get Extended ACL
message GetExtendedACLResponse {
  // Get Extended ACL Response body can be empty if the requested container does
  // not have Extended ACL Table attached or Extended ACL has not been allowed at
  // the time of container creation.
  message Body {
    // Extended ACL requested, if available
    neo.fs.v2.acl.EACLTable eacl = 1;

    // Signature of stable-marshalled Extended ACL according to RFC-6979.
    neo.fs.v2.refs.SignatureRFC6979 signature = 2;

    // Session token if Extended ACL was set within a session
    neo.fs.v2.session.SessionToken session_token = 3;
  }
  // Body of get extended acl response message.
  Body body = 1;

  // Carries response meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.ResponseMetaHeader meta_header = 2;

  // Carries response verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.ResponseVerificationHeader verify_header = 3;
}

// Announce container used space
//
// DEPRECATED: every storage node must send storage load directly to `container`
// contract.
message AnnounceUsedSpaceRequest {
  // Container used space announcement body.
  message Body {
    // Announcement contains used space information for a single container.
    message Announcement {
      // Epoch number for which the container size estimation was produced.
      uint64 epoch = 1;

      // Identifier of the container.
      neo.fs.v2.refs.ContainerID container_id = 2;

      // Used space is a sum of object payload sizes of a specified
      // container, stored in the node. It must not include inhumed objects.
      uint64 used_space = 3;
    }

    // List of announcements. If nodes share several containers,
    // announcements are transferred in a batch.
    repeated Announcement announcements = 1;
  }

  // Body of announce used space request message.
  Body body = 1;

  // Carries request meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.RequestMetaHeader meta_header = 2;

  // Carries request verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.RequestVerificationHeader verify_header = 3;
}

// Announce container used space
//
// DEPRECATED: every storage node must send storage load directly to `container`
// contract.
message AnnounceUsedSpaceResponse {
  // `AnnounceUsedSpaceResponse` has an empty body because announcements are
  // one way communication.
  message Body {}

  // Body of announce used space response message.
  Body body = 1;

  // Carries response meta information. Header data is used only to regulate
  // message transport and does not affect request execution.
  neo.fs.v2.session.ResponseMetaHeader meta_header = 2;

  // Carries response verification information. This header is used to
  // authenticate the nodes of the message route and check the correctness of
  // transmission.
  neo.fs.v2.session.ResponseVerificationHeader verify_header = 3;
}

// Attribute setting request
message SetAttributeRequest {
  // Request payload message.
  message Body {
    // Op parameters message.
    //
    // If container does not have the `attribute`, it is added. Otherwise, its
    // value is swapped.
    //
    // `valid_until` is required request expiration time in Unix Timestamp
    // format.
    //
    // `attribute` must be one of:
    //  - `CORS`;
    //  - `__NEOFS__LOCK_UNTIL`.
    //
    // In general, requirements for `value` are the same as for container
    // creation. Attribute-specific requirements:
    //  - `__NEOFS__LOCK_UNTIL`: new timestamp must be after the current one if any
    message Parameters {
      // Identifier of the container to set attribute for.
      neo.fs.v2.refs.ContainerID container_id = 1;

      // Attribute to be set.
      string attribute = 2;

      // New attribute value.
      string value = 3;

      // Request expiration time.
      uint64 valid_until = 4;
    }

    // Op parameters.
    Parameters parameters = 1;

    // N3 witness of stable-marshalled `parameters` field. The
    // signature must authenticate either container owner or one of subjects in
    // the `session_token` field if any. Signature according to
    // `ECDSA_RFC6979_SHA256` scheme is also supported.
    neo.fs.v2.refs.SignatureRFC6979 signature = 2;

    // Optional session token. The token must be issued by the container owner.
    // The token must have at least one subject authenticated by `signature`
    // field. The token must have at least one context with this container and
    // `CONTAINER_SETATTRIBUTE` verb.
    neo.fs.v2.session.SessionTokenV2 session_token = 3;

    // Optional session token (V1). It must not be set together with
    // `session_token` field that is highly recommended to be used instead.
    // Requirements are the same for both.
    neo.fs.v2.session.SessionToken session_token_v1 = 4;
  }

  // Request payload.
  Body body = 1;

  // Signature of stable-marshalled `body` field.
  neo.fs.v2.refs.Signature body_signature = 2;
}

// Attribute setting response
message SetAttributeResponse {
  // Request result message.
  message Body {
    // Operation execution status.
    neo.fs.v2.status.Status status = 1;
  }

  // Request result.
  Body body = 1;

  // Signature of stable-marshalled `body` field.
  neo.fs.v2.refs.Signature body_signature = 2;
}

// Attribute removal request
message RemoveAttributeRequest {
  // Request payload message.
  message Body {
    // Op parameters message.
    //
    // If container does not have the `attribute`, nothing is done and status
    // `OK` is returned.
    //
    // `valid_until` is required request expiration time in Unix Timestamp
    // format.
    //
    // `attribute` must be one of:
    //  - `CORS`;
    //  - `__NEOFS__LOCK_UNTIL`.
    //
    // Attribute-specific requirements:
    //  - `__NEOFS__LOCK_UNTIL`: current timestamp must have already passed if any
    message Parameters {
      // Identifier of the container to remove attribute from.
      neo.fs.v2.refs.ContainerID container_id = 1;

      // Attribute to be removed.
      string attribute = 2;

      // Request expiration time.
      uint64 valid_until = 3;
    }

    // Op parameters.
    Parameters parameters = 1;

    // N3 witness of stable-marshalled `parameters` field. The
    // signature must authenticate either container owner or one of subjects in
    // the `session_token` field if any. Signature according to
    // `ECDSA_RFC6979_SHA256` scheme is also supported.
    neo.fs.v2.refs.SignatureRFC6979 signature = 2;

    // Optional session token. The token must be issued by the container owner.
    // The token must have at least one subject authenticated by `signature`
    // field. The token must have at least one context with this container and
    // `CONTAINER_REMOVEATTRIBUTE` verb.
    neo.fs.v2.session.SessionTokenV2 session_token = 3;

    // Optional session token (V1). It must not be set together with
    // `session_token` field that is highly recommended to be used instead.
    // Requirements are the same for both.
    neo.fs.v2.session.SessionToken session_token_v1 = 4;
  }

  // Request payload.
  Body body = 1;

  // Signature of stable-marshalled `body` field.
  neo.fs.v2.refs.Signature body_signature = 2;
}

// Attribute removal response
message RemoveAttributeResponse {
  // Request result message.
  message Body {
    // Operation execution status.
    neo.fs.v2.status.Status status = 1;
  }

  // Request result.
  Body body = 1;

  // Signature of stable-marshalled `body` field.
  neo.fs.v2.refs.Signature body_signature = 2;
}
